# Generated from expr.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3-")
        buf.write("y\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t")
        buf.write("\16\4\17\t\17\3\2\3\2\3\2\3\2\3\3\7\3$\n\3\f\3\16\3\'")
        buf.write("\13\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4\60\n\4\3\4\3\4\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\7\5:\n\5\f\5\16\5=\13\5\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\7\6E\n\6\f\6\16\6H\13\6\3\7\3\7\3\7\7")
        buf.write("\7M\n\7\f\7\16\7P\13\7\3\b\3\b\3\b\3\b\3\b\3\b\5\bX\n")
        buf.write("\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\ta\n\t\3\n\3\n\3\13\3")
        buf.write("\13\3\f\3\f\3\r\3\r\3\r\3\r\3\r\7\rn\n\r\f\r\16\rq\13")
        buf.write("\r\3\r\3\r\3\16\3\16\3\17\3\17\3\17\2\4\b\n\20\2\4\6\b")
        buf.write("\n\f\16\20\22\24\26\30\32\34\2\7\3\2\32\33\3\2\34\35\3")
        buf.write("\2&(\3\2\3\27\3\2\36 \2v\2\36\3\2\2\2\4%\3\2\2\2\6(\3")
        buf.write("\2\2\2\b\63\3\2\2\2\n>\3\2\2\2\fI\3\2\2\2\16W\3\2\2\2")
        buf.write("\20`\3\2\2\2\22b\3\2\2\2\24d\3\2\2\2\26f\3\2\2\2\30h\3")
        buf.write("\2\2\2\32t\3\2\2\2\34v\3\2\2\2\36\37\5\b\5\2\37 \5\34")
        buf.write("\17\2 !\5\b\5\2!\3\3\2\2\2\"$\5\6\4\2#\"\3\2\2\2$\'\3")
        buf.write("\2\2\2%#\3\2\2\2%&\3\2\2\2&\5\3\2\2\2\'%\3\2\2\2()\5\26")
        buf.write("\f\2)*\7\"\2\2*+\5\b\5\2+,\7)\2\2,/\5\b\5\2-.\7*\2\2.")
        buf.write("\60\5\2\2\2/-\3\2\2\2/\60\3\2\2\2\60\61\3\2\2\2\61\62")
        buf.write("\7#\2\2\62\7\3\2\2\2\63\64\b\5\1\2\64\65\5\n\6\2\65;\3")
        buf.write("\2\2\2\66\67\f\4\2\2\678\t\2\2\28:\5\n\6\29\66\3\2\2\2")
        buf.write(":=\3\2\2\2;9\3\2\2\2;<\3\2\2\2<\t\3\2\2\2=;\3\2\2\2>?")
        buf.write("\b\6\1\2?@\5\f\7\2@F\3\2\2\2AB\f\4\2\2BC\t\3\2\2CE\5\f")
        buf.write("\7\2DA\3\2\2\2EH\3\2\2\2FD\3\2\2\2FG\3\2\2\2G\13\3\2\2")
        buf.write("\2HF\3\2\2\2IN\5\16\b\2JK\7%\2\2KM\5\16\b\2LJ\3\2\2\2")
        buf.write("MP\3\2\2\2NL\3\2\2\2NO\3\2\2\2O\r\3\2\2\2PN\3\2\2\2QR")
        buf.write("\7\32\2\2RX\5\16\b\2ST\7\33\2\2TX\5\16\b\2UX\5\30\r\2")
        buf.write("VX\5\20\t\2WQ\3\2\2\2WS\3\2\2\2WU\3\2\2\2WV\3\2\2\2X\17")
        buf.write("\3\2\2\2Ya\5\22\n\2Za\5\26\f\2[a\5\24\13\2\\]\7\30\2\2")
        buf.write("]^\5\b\5\2^_\7\31\2\2_a\3\2\2\2`Y\3\2\2\2`Z\3\2\2\2`[")
        buf.write("\3\2\2\2`\\\3\2\2\2a\21\3\2\2\2bc\7,\2\2c\23\3\2\2\2d")
        buf.write("e\t\4\2\2e\25\3\2\2\2fg\7+\2\2g\27\3\2\2\2hi\5\32\16\2")
        buf.write("ij\7\30\2\2jo\5\b\5\2kl\7!\2\2ln\5\b\5\2mk\3\2\2\2nq\3")
        buf.write("\2\2\2om\3\2\2\2op\3\2\2\2pr\3\2\2\2qo\3\2\2\2rs\7\31")
        buf.write("\2\2s\31\3\2\2\2tu\t\5\2\2u\33\3\2\2\2vw\t\6\2\2w\35\3")
        buf.write("\2\2\2\n%/;FNW`o")
        return buf.getvalue()


class exprParser ( Parser ):

    grammarFileName = "expr.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'pow'", "'exp'", "'cos'", "'cosh'", "'sin'", 
                     "'tan'", "'cot'", "'sec'", "'csc'", "'acos'", "'asin'", 
                     "'atan'", "'ln'", "'log'", "'sqrt'", "'gamma'", "'bnl'", 
                     "'sum'", "'abs'", "'fac'", "'get_arc'", "'('", "')'", 
                     "'+'", "'-'", "'*'", "'/'", "'>'", "'<'", "'='", "','", 
                     "':'", "';'", "'.'", "<INVALID>", "'pi'", "'r'", "'I'", 
                     "'->'", "'@'" ]

    symbolicNames = [ "<INVALID>", "POWF", "EXP", "COS", "COSH", "SIN", 
                      "TAN", "COT", "SEC", "CSC", "ACOS", "ASIN", "ATAN", 
                      "LN", "LOG", "SQRT", "GAMMA", "BERNOULLI", "SUM", 
                      "ABS", "FACTORIAL", "GET_ARC", "LPAREN", "RPAREN", 
                      "PLUS", "MINUS", "TIMES", "DIV", "GT", "LT", "EQ", 
                      "COMMA", "COLON", "SEMICOLON", "POINT", "POW", "PI", 
                      "EULER", "I", "ARROW", "AT", "VARIABLE", "SCIENTIFIC_NUMBER", 
                      "WS" ]

    RULE_equation = 0
    RULE_rules = 1
    RULE_singleRule = 2
    RULE_expression = 3
    RULE_multiplyingExpression = 4
    RULE_powExpression = 5
    RULE_signedAtom = 6
    RULE_atom = 7
    RULE_scientific = 8
    RULE_constant = 9
    RULE_variable = 10
    RULE_func = 11
    RULE_funcname = 12
    RULE_relop = 13

    ruleNames =  [ "equation", "rules", "singleRule", "expression", "multiplyingExpression", 
                   "powExpression", "signedAtom", "atom", "scientific", 
                   "constant", "variable", "func", "funcname", "relop" ]

    EOF = Token.EOF
    POWF=1
    EXP=2
    COS=3
    COSH=4
    SIN=5
    TAN=6
    COT=7
    SEC=8
    CSC=9
    ACOS=10
    ASIN=11
    ATAN=12
    LN=13
    LOG=14
    SQRT=15
    GAMMA=16
    BERNOULLI=17
    SUM=18
    ABS=19
    FACTORIAL=20
    GET_ARC=21
    LPAREN=22
    RPAREN=23
    PLUS=24
    MINUS=25
    TIMES=26
    DIV=27
    GT=28
    LT=29
    EQ=30
    COMMA=31
    COLON=32
    SEMICOLON=33
    POINT=34
    POW=35
    PI=36
    EULER=37
    I=38
    ARROW=39
    AT=40
    VARIABLE=41
    SCIENTIFIC_NUMBER=42
    WS=43

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class EquationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(exprParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(exprParser.ExpressionContext,i)


        def relop(self):
            return self.getTypedRuleContext(exprParser.RelopContext,0)


        def getRuleIndex(self):
            return exprParser.RULE_equation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquation" ):
                listener.enterEquation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquation" ):
                listener.exitEquation(self)




    def equation(self):

        localctx = exprParser.EquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_equation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 28
            self.expression(0)
            self.state = 29
            self.relop()
            self.state = 30
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RulesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(exprParser.SingleRuleContext)
            else:
                return self.getTypedRuleContext(exprParser.SingleRuleContext,i)


        def getRuleIndex(self):
            return exprParser.RULE_rules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRules" ):
                listener.enterRules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRules" ):
                listener.exitRules(self)




    def rules(self):

        localctx = exprParser.RulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_rules)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 35
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==exprParser.VARIABLE:
                self.state = 32
                self.singleRule()
                self.state = 37
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SingleRuleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(exprParser.VariableContext,0)


        def COLON(self):
            return self.getToken(exprParser.COLON, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(exprParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(exprParser.ExpressionContext,i)


        def ARROW(self):
            return self.getToken(exprParser.ARROW, 0)

        def SEMICOLON(self):
            return self.getToken(exprParser.SEMICOLON, 0)

        def AT(self):
            return self.getToken(exprParser.AT, 0)

        def equation(self):
            return self.getTypedRuleContext(exprParser.EquationContext,0)


        def getRuleIndex(self):
            return exprParser.RULE_singleRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleRule" ):
                listener.enterSingleRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleRule" ):
                listener.exitSingleRule(self)




    def singleRule(self):

        localctx = exprParser.SingleRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_singleRule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 38
            self.variable()
            self.state = 39
            self.match(exprParser.COLON)
            self.state = 40
            self.expression(0)
            self.state = 41
            self.match(exprParser.ARROW)
            self.state = 42
            self.expression(0)
            self.state = 45
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==exprParser.AT:
                self.state = 43
                self.match(exprParser.AT)
                self.state = 44
                self.equation()


            self.state = 47
            self.match(exprParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplyingExpression(self):
            return self.getTypedRuleContext(exprParser.MultiplyingExpressionContext,0)


        def expression(self):
            return self.getTypedRuleContext(exprParser.ExpressionContext,0)


        def PLUS(self):
            return self.getToken(exprParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(exprParser.MINUS, 0)

        def getRuleIndex(self):
            return exprParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = exprParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 6
        self.enterRecursionRule(localctx, 6, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self.multiplyingExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 57
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = exprParser.ExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 52
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 53
                    _la = self._input.LA(1)
                    if not(_la==exprParser.PLUS or _la==exprParser.MINUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 54
                    self.multiplyingExpression(0) 
                self.state = 59
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class MultiplyingExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def powExpression(self):
            return self.getTypedRuleContext(exprParser.PowExpressionContext,0)


        def multiplyingExpression(self):
            return self.getTypedRuleContext(exprParser.MultiplyingExpressionContext,0)


        def TIMES(self):
            return self.getToken(exprParser.TIMES, 0)

        def DIV(self):
            return self.getToken(exprParser.DIV, 0)

        def getRuleIndex(self):
            return exprParser.RULE_multiplyingExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplyingExpression" ):
                listener.enterMultiplyingExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplyingExpression" ):
                listener.exitMultiplyingExpression(self)



    def multiplyingExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = exprParser.MultiplyingExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 8
        self.enterRecursionRule(localctx, 8, self.RULE_multiplyingExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.powExpression()
            self._ctx.stop = self._input.LT(-1)
            self.state = 68
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = exprParser.MultiplyingExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multiplyingExpression)
                    self.state = 63
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 64
                    _la = self._input.LA(1)
                    if not(_la==exprParser.TIMES or _la==exprParser.DIV):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 65
                    self.powExpression() 
                self.state = 70
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class PowExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signedAtom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(exprParser.SignedAtomContext)
            else:
                return self.getTypedRuleContext(exprParser.SignedAtomContext,i)


        def POW(self, i:int=None):
            if i is None:
                return self.getTokens(exprParser.POW)
            else:
                return self.getToken(exprParser.POW, i)

        def getRuleIndex(self):
            return exprParser.RULE_powExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowExpression" ):
                listener.enterPowExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowExpression" ):
                listener.exitPowExpression(self)




    def powExpression(self):

        localctx = exprParser.PowExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_powExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 71
            self.signedAtom()
            self.state = 76
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 72
                    self.match(exprParser.POW)
                    self.state = 73
                    self.signedAtom() 
                self.state = 78
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SignedAtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(exprParser.PLUS, 0)

        def signedAtom(self):
            return self.getTypedRuleContext(exprParser.SignedAtomContext,0)


        def MINUS(self):
            return self.getToken(exprParser.MINUS, 0)

        def func(self):
            return self.getTypedRuleContext(exprParser.FuncContext,0)


        def atom(self):
            return self.getTypedRuleContext(exprParser.AtomContext,0)


        def getRuleIndex(self):
            return exprParser.RULE_signedAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignedAtom" ):
                listener.enterSignedAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignedAtom" ):
                listener.exitSignedAtom(self)




    def signedAtom(self):

        localctx = exprParser.SignedAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_signedAtom)
        try:
            self.state = 85
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [exprParser.PLUS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 79
                self.match(exprParser.PLUS)
                self.state = 80
                self.signedAtom()
                pass
            elif token in [exprParser.MINUS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 81
                self.match(exprParser.MINUS)
                self.state = 82
                self.signedAtom()
                pass
            elif token in [exprParser.POWF, exprParser.EXP, exprParser.COS, exprParser.COSH, exprParser.SIN, exprParser.TAN, exprParser.COT, exprParser.SEC, exprParser.CSC, exprParser.ACOS, exprParser.ASIN, exprParser.ATAN, exprParser.LN, exprParser.LOG, exprParser.SQRT, exprParser.GAMMA, exprParser.BERNOULLI, exprParser.SUM, exprParser.ABS, exprParser.FACTORIAL, exprParser.GET_ARC]:
                self.enterOuterAlt(localctx, 3)
                self.state = 83
                self.func()
                pass
            elif token in [exprParser.LPAREN, exprParser.PI, exprParser.EULER, exprParser.I, exprParser.VARIABLE, exprParser.SCIENTIFIC_NUMBER]:
                self.enterOuterAlt(localctx, 4)
                self.state = 84
                self.atom()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scientific(self):
            return self.getTypedRuleContext(exprParser.ScientificContext,0)


        def variable(self):
            return self.getTypedRuleContext(exprParser.VariableContext,0)


        def constant(self):
            return self.getTypedRuleContext(exprParser.ConstantContext,0)


        def LPAREN(self):
            return self.getToken(exprParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(exprParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(exprParser.RPAREN, 0)

        def getRuleIndex(self):
            return exprParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)




    def atom(self):

        localctx = exprParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_atom)
        try:
            self.state = 94
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [exprParser.SCIENTIFIC_NUMBER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 87
                self.scientific()
                pass
            elif token in [exprParser.VARIABLE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 88
                self.variable()
                pass
            elif token in [exprParser.PI, exprParser.EULER, exprParser.I]:
                self.enterOuterAlt(localctx, 3)
                self.state = 89
                self.constant()
                pass
            elif token in [exprParser.LPAREN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 90
                self.match(exprParser.LPAREN)
                self.state = 91
                self.expression(0)
                self.state = 92
                self.match(exprParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ScientificContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCIENTIFIC_NUMBER(self):
            return self.getToken(exprParser.SCIENTIFIC_NUMBER, 0)

        def getRuleIndex(self):
            return exprParser.RULE_scientific

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScientific" ):
                listener.enterScientific(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScientific" ):
                listener.exitScientific(self)




    def scientific(self):

        localctx = exprParser.ScientificContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_scientific)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.match(exprParser.SCIENTIFIC_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PI(self):
            return self.getToken(exprParser.PI, 0)

        def EULER(self):
            return self.getToken(exprParser.EULER, 0)

        def I(self):
            return self.getToken(exprParser.I, 0)

        def getRuleIndex(self):
            return exprParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = exprParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << exprParser.PI) | (1 << exprParser.EULER) | (1 << exprParser.I))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLE(self):
            return self.getToken(exprParser.VARIABLE, 0)

        def getRuleIndex(self):
            return exprParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)




    def variable(self):

        localctx = exprParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(exprParser.VARIABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def funcname(self):
            return self.getTypedRuleContext(exprParser.FuncnameContext,0)


        def LPAREN(self):
            return self.getToken(exprParser.LPAREN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(exprParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(exprParser.ExpressionContext,i)


        def RPAREN(self):
            return self.getToken(exprParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(exprParser.COMMA)
            else:
                return self.getToken(exprParser.COMMA, i)

        def getRuleIndex(self):
            return exprParser.RULE_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc" ):
                listener.enterFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc" ):
                listener.exitFunc(self)




    def func(self):

        localctx = exprParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_func)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.funcname()
            self.state = 103
            self.match(exprParser.LPAREN)
            self.state = 104
            self.expression(0)
            self.state = 109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==exprParser.COMMA:
                self.state = 105
                self.match(exprParser.COMMA)
                self.state = 106
                self.expression(0)
                self.state = 111
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 112
            self.match(exprParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FuncnameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COS(self):
            return self.getToken(exprParser.COS, 0)

        def COSH(self):
            return self.getToken(exprParser.COSH, 0)

        def POWF(self):
            return self.getToken(exprParser.POWF, 0)

        def EXP(self):
            return self.getToken(exprParser.EXP, 0)

        def TAN(self):
            return self.getToken(exprParser.TAN, 0)

        def SIN(self):
            return self.getToken(exprParser.SIN, 0)

        def SEC(self):
            return self.getToken(exprParser.SEC, 0)

        def CSC(self):
            return self.getToken(exprParser.CSC, 0)

        def COT(self):
            return self.getToken(exprParser.COT, 0)

        def ACOS(self):
            return self.getToken(exprParser.ACOS, 0)

        def ATAN(self):
            return self.getToken(exprParser.ATAN, 0)

        def ASIN(self):
            return self.getToken(exprParser.ASIN, 0)

        def LOG(self):
            return self.getToken(exprParser.LOG, 0)

        def LN(self):
            return self.getToken(exprParser.LN, 0)

        def SQRT(self):
            return self.getToken(exprParser.SQRT, 0)

        def GAMMA(self):
            return self.getToken(exprParser.GAMMA, 0)

        def BERNOULLI(self):
            return self.getToken(exprParser.BERNOULLI, 0)

        def SUM(self):
            return self.getToken(exprParser.SUM, 0)

        def ABS(self):
            return self.getToken(exprParser.ABS, 0)

        def FACTORIAL(self):
            return self.getToken(exprParser.FACTORIAL, 0)

        def GET_ARC(self):
            return self.getToken(exprParser.GET_ARC, 0)

        def getRuleIndex(self):
            return exprParser.RULE_funcname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncname" ):
                listener.enterFuncname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncname" ):
                listener.exitFuncname(self)




    def funcname(self):

        localctx = exprParser.FuncnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_funcname)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << exprParser.POWF) | (1 << exprParser.EXP) | (1 << exprParser.COS) | (1 << exprParser.COSH) | (1 << exprParser.SIN) | (1 << exprParser.TAN) | (1 << exprParser.COT) | (1 << exprParser.SEC) | (1 << exprParser.CSC) | (1 << exprParser.ACOS) | (1 << exprParser.ASIN) | (1 << exprParser.ATAN) | (1 << exprParser.LN) | (1 << exprParser.LOG) | (1 << exprParser.SQRT) | (1 << exprParser.GAMMA) | (1 << exprParser.BERNOULLI) | (1 << exprParser.SUM) | (1 << exprParser.ABS) | (1 << exprParser.FACTORIAL) | (1 << exprParser.GET_ARC))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(exprParser.EQ, 0)

        def GT(self):
            return self.getToken(exprParser.GT, 0)

        def LT(self):
            return self.getToken(exprParser.LT, 0)

        def getRuleIndex(self):
            return exprParser.RULE_relop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelop" ):
                listener.enterRelop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelop" ):
                listener.exitRelop(self)




    def relop(self):

        localctx = exprParser.RelopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_relop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << exprParser.GT) | (1 << exprParser.LT) | (1 << exprParser.EQ))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[3] = self.expression_sempred
        self._predicates[4] = self.multiplyingExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def multiplyingExpression_sempred(self, localctx:MultiplyingExpressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         




